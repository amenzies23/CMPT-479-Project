#pragma once

#include <nlohmann/json.hpp>
#include <string>
#include <vector>
#include <unordered_map>

namespace apr_system {

// forward declarations
struct TestResult;
struct CoverageData;
struct SuspiciousLocation;
struct ASTNode;
struct PatchCandidate;
struct PrioritizedPatch;
struct ValidationResult;
struct PRResult;

/**
 * @brief test execution result
 */
struct TestResult {
  std::string test_name;
  bool passed;
  long long execution_time_ms;
  std::string output;
  std::string error_message;

  NLOHMANN_DEFINE_TYPE_INTRUSIVE(TestResult, test_name, passed,
                                 execution_time_ms, output, error_message)
};

/**
 * @brief code coverage information for a line
 */
struct LineCoverage {
  std::string file_path;
  int line_number;
  int hit_count;
  bool covered;

  NLOHMANN_DEFINE_TYPE_INTRUSIVE(LineCoverage, file_path, line_number,
                                 hit_count, covered)
};

/**
 * @brief coverage data for the entire test suite
 */
struct CoverageData {
  std::vector<LineCoverage> line_coverage;
  std::vector<std::string> covered_files;
  double total_coverage_percentage;

  NLOHMANN_DEFINE_TYPE_INTRUSIVE(CoverageData, line_coverage, covered_files,
                                 total_coverage_percentage)
};

/**
 * @brief suspicious location identified by sbfl
 */
struct SuspiciousLocation {
  std::string file_path;
  int line_number;
  double suspiciousness_score;
  std::string function;
  std::string reason;

  NLOHMANN_DEFINE_TYPE_INTRUSIVE(SuspiciousLocation, file_path, line_number,
                                 suspiciousness_score, function, reason)
};

using TypeCountMap = std::unordered_map<std::string,int>;

struct GenealogyContext {
  std::unordered_map<std::string,int> type_counts;

  NLOHMANN_DEFINE_TYPE_INTRUSIVE(GenealogyContext, type_counts)
};

struct VariableContext {
  std::unordered_map<std::string,int> var_counts;

  NLOHMANN_DEFINE_TYPE_INTRUSIVE(VariableContext, var_counts)
};

struct DependencyContext {
  TypeCountMap slice_counts;

  NLOHMANN_DEFINE_TYPE_INTRUSIVE(DependencyContext, slice_counts)
};


/**
 * @brief ast node information
 */
struct ASTNode {
  std::string node_id;
  std::string node_type;
  int start_line;
  int end_line;
  int start_column;
  int end_column;
  std::string file_path;
  std::string source_text;
  std::vector<std::string> child_node_ids;
  double suspiciousness_score;
  std::string sbfl_reason;
  GenealogyContext genealogy_context;
  VariableContext variable_context;
  DependencyContext dependency_context;

  NLOHMANN_DEFINE_TYPE_INTRUSIVE(ASTNode, node_id, node_type, start_line,
                                 end_line, start_column, end_column, file_path,
                                 source_text, child_node_ids,suspiciousness_score,sbfl_reason, 
                                 genealogy_context, variable_context, dependency_context)
};

/**
 * @brief patch candidate generated by mutator
 */
struct PatchCandidate {
  std::string patch_id;
  std::string file_path;
  int start_line;
  int end_line;
  std::string original_code;
  std::string modified_code;
  std::string diff;
  std::string mutation_type;
  std::vector<std::string> affected_tests;

  NLOHMANN_DEFINE_TYPE_INTRUSIVE(PatchCandidate, patch_id, file_path,
                                 start_line, end_line, original_code,
                                 modified_code, diff, mutation_type,
                                 affected_tests)
};

/**
 * @brief prioritized patch with ranking score
 */
struct PrioritizedPatch {
  std::string patch_id;
  double priority_score;
  std::string patch_id_ref;
  std::vector<std::string> features;
  std::string reasoning;

  NLOHMANN_DEFINE_TYPE_INTRUSIVE(PrioritizedPatch, patch_id, priority_score,
                                 patch_id_ref, features, reasoning)
};

/**
 * @brief validation result for a patch
 */
struct ValidationResult {
  std::string patch_id;
  bool compilation_success;
  bool tests_passed;
  long long build_time_ms;
  long long test_time_ms;
  std::string build_output;
  std::string test_output;
  std::string error_message;
  int tests_passed_count;
  int tests_total_count;

  NLOHMANN_DEFINE_TYPE_INTRUSIVE(ValidationResult, patch_id,
                                 compilation_success, tests_passed,
                                 build_time_ms, test_time_ms, build_output,
                                 test_output, error_message, tests_passed_count,
                                 tests_total_count)
};

/**
 * @brief pull request creation result
 */
struct PRResult {
  std::string pr_url;
  std::string branch_name;
  std::string commit_hash;
  std::string title;
  std::string description;
  bool success;
  std::string error_message;

  NLOHMANN_DEFINE_TYPE_INTRUSIVE(PRResult, pr_url, branch_name, commit_hash,
                                 title, description, success, error_message)
};

/**
 * @brief repository metadata
 */
struct RepositoryMetadata {
  std::string repository_url;
  std::string branch;
  std::string commit_hash;
  std::string build_script;
  std::string test_script;
  std::vector<std::string> source_files;

  NLOHMANN_DEFINE_TYPE_INTRUSIVE(RepositoryMetadata, repository_url, branch,
                                 commit_hash, build_script, test_script,
                                 source_files)
};

/**
 * @brief complete system state
 */
struct SystemState {
  RepositoryMetadata repo_metadata;
  // might not be needed
//   std::vector<TestResult> test_results;
//   CoverageData coverage_data;
  std::vector<SuspiciousLocation> suspicious_locations;
  std::vector<ASTNode> ast_nodes;
  std::vector<PatchCandidate> patch_candidates;
  std::vector<PrioritizedPatch> prioritized_patches;
  std::vector<ValidationResult> validation_results;
  bool has_pr_result;
  PRResult pr_result;

  NLOHMANN_DEFINE_TYPE_INTRUSIVE(SystemState, repo_metadata,
                                 suspicious_locations, ast_nodes,
                                 patch_candidates, prioritized_patches,
                                 validation_results, has_pr_result, pr_result)
};

} // namespace apr_system
